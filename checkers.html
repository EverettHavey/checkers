<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Multiplayer Checkers Game</title>
    <script type="module">
        // Import necessary Firebase modules
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInWithCustomToken, onAuthStateChanged, signInAnonymously } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, doc, getDoc, setDoc, onSnapshot, collection, query, where, updateDoc, getDocs } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

        // Global variables provided by the Canvas environment
        const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';
        const firebaseConfig = typeof __firebase_config !== 'undefined' ? JSON.parse(__firebase_config) : {};
        const initialAuthToken = typeof __initial_auth_token !== 'undefined' ? __initial_auth_token : null;

        // Initialize Firebase services and store references
        let app, db, auth;

        // Game state variables
        let userId = null;
        let username = 'Player';
        let gameId = null;
        let board = [];
        let currentPlayer = null;
        let selectedPiece = null;
        let isGameOver = false;
        let playerColor = null;
        let isBotGame = false;
        let botName = 'Checkers Bot';
        let waitingForOpponent = false;

        // Game UI elements
        const mainMenu = document.getElementById('main-menu');
        const gameContainer = document.getElementById('game-container');
        const boardElement = document.getElementById('game-board');
        const messageBox = document.getElementById('message-box');
        const waitingScreen = document.getElementById('waiting-screen');
        const userIdDisplay = document.getElementById('user-id');
        const usernameInput = document.getElementById('username-input');
        const otherUserIdInput = document.getElementById('other-user-id-input');
        const turnDisplay = document.getElementById('turn-display');
        const undoButton = document.getElementById('undo-button');

        // --- Firebase Initialization and Authentication ---
        async function initFirebase() {
            try {
                // Check if firebaseConfig is not an empty object
                if (Object.keys(firebaseConfig).length === 0) {
                    console.error("Firebase Configuration Error: firebaseConfig is empty or malformed.");
                    showMessage("Failed to connect to the database. Firebase configuration is missing or invalid.", 0);
                    return;
                }

                app = initializeApp(firebaseConfig);
                db = getFirestore(app);
                auth = getAuth(app);

                // Sign in with custom token or anonymously if not available
                if (initialAuthToken) {
                    await signInWithCustomToken(auth, initialAuthToken);
                } else {
                    await signInAnonymously(auth);
                }

                // Listen for authentication state changes
                onAuthStateChanged(auth, (user) => {
                    if (user) {
                        userId = user.uid;
                        console.log("Firebase authenticated. User ID:", userId);
                        updateUsernameDisplay();
                    } else {
                        console.log("No user signed in.");
                        showMessage("Authentication failed. Please refresh the page.", 5000);
                    }
                });
            } catch (error) {
                console.error("Firebase Init Error:", error);
                showMessage("Failed to connect to the database. Please try again later.", 5000);
            }
        }

        // --- UI & State Management ---

        function showMessage(text, duration = 3000) {
            messageBox.textContent = text;
            messageBox.classList.add('show');
            if (duration > 0) {
                setTimeout(() => {
                    messageBox.classList.remove('show');
                }, duration);
            }
        }

        function showWaitingScreen(message) {
            waitingScreen.style.display = 'flex';
            document.getElementById('waiting-message').textContent = message;
        }

        function hideWaitingScreen() {
            waitingScreen.style.display = 'none';
        }

        function showGame() {
            mainMenu.style.display = 'none';
            gameContainer.style.display = 'flex';
        }

        function showMainMenu() {
            mainMenu.style.display = 'flex';
            gameContainer.style.display = 'none';
            resetLocalState();
        }

        function updateUsernameDisplay() {
            username = usernameInput.value.trim() || 'Player';
            // Display both the user's chosen name and their unique ID
            userIdDisplay.innerHTML = `Your username: **${username}**<br>Your User ID: ${userId}`;
        }
        
        usernameInput.addEventListener('input', updateUsernameDisplay);

        function resetLocalState() {
            // Fix: Initialize board with an 8x8 array of nulls to prevent rendering errors
            board = Array(8).fill(null).map(() => Array(8).fill(null));
            currentPlayer = null;
            selectedPiece = null;
            isGameOver = false;
            playerColor = null;
            isBotGame = false;
            waitingForOpponent = false;
            gameId = null;
            undoButton.style.display = 'none';
            renderBoard();
        }
        
        // --- Game Flow Functions ---

        window.startNewGame = async function() {
            if (!userId) {
                showMessage("Authentication not ready. Please wait.", 3000);
                return;
            }
            updateUsernameDisplay();
            isBotGame = false;
            undoButton.style.display = 'none';
            waitingForOpponent = true;

            try {
                showWaitingScreen("Creating new game and waiting for a player to join...");
                const newGameRef = doc(collection(db, `artifacts/${appId}/public/data/games`));
                gameId = newGameRef.id;

                await setDoc(newGameRef, {
                    player1: userId,
                    player1Name: username,
                    player2: null,
                    player2Name: null,
                    board: JSON.stringify(createInitialBoard()),
                    turn: 'black',
                    status: 'waiting',
                    winner: null
                });

                showMessage("Game created! Waiting for another player...", 0);
                showGame();
                playerColor = 'black';
                listenToGameChanges();
            } catch (e) {
                console.error("Error creating game:", e);
                showMessage("Failed to create game. Please try again.", 5000);
                showMainMenu();
            }
        }

        window.joinGame = async function() {
            if (!userId) {
                showMessage("Authentication not ready. Please wait.", 3000);
                return;
            }
            updateUsernameDisplay();
            isBotGame = false;
            undoButton.style.display = 'none';
            const otherUserId = otherUserIdInput.value.trim();
            if (!otherUserId) {
                showMessage("Please enter a User ID to join.", 3000);
                return;
            }
            
            showWaitingScreen(`Searching for a game created by User ID: "${otherUserId}"...`);
            try {
                const gamesRef = collection(db, `artifacts/${appId}/public/data/games`);
                // Query for a game created by the other user's ID
                const q = query(gamesRef, where("player1", "==", otherUserId), where("status", "==", "waiting"));
                const querySnapshot = await getDocs(q);

                if (!querySnapshot.empty) {
                    const gameDoc = querySnapshot.docs[0];
                    gameId = gameDoc.id;
                    await updateDoc(doc(db, `artifacts/${appId}/public/data/games`, gameId), {
                        player2: userId,
                        player2Name: username,
                        status: 'in-progress'
                    });

                    showMessage("Joined game successfully! Starting...", 0);
                    showGame();
                    playerColor = 'red';
                    listenToGameChanges();
                } else {
                    showMessage("No available game found with that User ID.", 5000);
                }
            } catch (e) {
                console.error("Error joining game:", e);
                showMessage("Failed to join game. Please check the User ID.", 5000);
            } finally {
                hideWaitingScreen();
            }
        }

        window.startBotGame = async function() {
            if (!userId) {
                showMessage("Authentication not ready. Please wait.", 3000);
                return;
            }
            updateUsernameDisplay();
            isBotGame = true;
            undoButton.style.display = 'inline-block';
            
            try {
                showWaitingScreen("Starting game against the bot...");
                const newGameRef = doc(collection(db, `artifacts/${appId}/public/data/games`));
                gameId = newGameRef.id;

                await setDoc(newGameRef, {
                    player1: userId,
                    player1Name: username,
                    player2: 'bot',
                    player2Name: botName,
                    board: JSON.stringify(createInitialBoard()),
                    turn: 'black',
                    status: 'in-progress',
                    winner: null
                });
                
                showMessage("Game started against the bot!", 0);
                showGame();
                playerColor = 'black';
                listenToGameChanges();
            } catch (e) {
                console.error("Error starting bot game:", e);
                showMessage("Failed to start bot game. Please try again.", 5000);
                showMainMenu();
            }
        }

        // Listens for changes to the game document in Firestore
        function listenToGameChanges() {
            const gameRef = doc(db, `artifacts/${appId}/public/data/games`, gameId);
            onSnapshot(gameRef, (docSnap) => {
                if (!docSnap.exists()) {
                    showMessage("Game not found or has ended.", 5000);
                    showMainMenu();
                    return;
                }
                
                const data = docSnap.data();
                board = JSON.parse(data.board);
                currentPlayer = data.turn;
                isGameOver = data.winner !== null;

                if (waitingForOpponent && data.status === 'in-progress') {
                    waitingForOpponent = false;
                    hideWaitingScreen();
                    showMessage("A player has joined! The game is starting.", 3000);
                }

                if (isGameOver) {
                    endGame(data.winner);
                } else {
                    renderBoard();
                    updateTurnDisplay(data.player1Name, data.player2Name);
                    
                    if (isBotGame && currentPlayer === 'red') {
                        setTimeout(makeBotMove, 1000);
                    }
                }
            }, (error) => {
                console.error("Error listening to game changes:", error);
                showMessage("Lost connection to the game. Please go back to the menu.", 5000);
            });
        }
        
        // --- Game Board & Piece Logic ---

        function createInitialBoard() {
            const initialBoard = [];
            for (let i = 0; i < 8; i++) {
                initialBoard.push([]);
                for (let j = 0; j < 8; j++) {
                    let piece = null;
                    if (i < 3 && (i + j) % 2 !== 0) {
                        piece = { color: 'red', king: false };
                    } else if (i > 4 && (i + j) % 2 !== 0) {
                        piece = { color: 'black', king: false };
                    }
                    initialBoard[i].push(piece);
                }
            }
            return initialBoard;
        }

        function renderBoard() {
            boardElement.innerHTML = '';
            for (let i = 0; i < 8; i++) {
                for (let j = 0; j < 8; j++) {
                    const square = document.createElement('div');
                    square.className = `square ${(i + j) % 2 === 0 ? 'light' : 'dark'}`;
                    square.dataset.row = i;
                    square.dataset.col = j;
                    square.addEventListener('click', () => handleSquareClick(i, j));

                    const piece = board[i][j];
                    if (piece) {
                        const pieceElement = document.createElement('div');
                        pieceElement.className = `piece ${piece.color} ${piece.king ? 'king' : ''}`;
                        square.appendChild(pieceElement);
                    }
                    boardElement.appendChild(square);
                }
            }
        }
        
        async function handleSquareClick(row, col) {
            if (isGameOver || currentPlayer !== playerColor) {
                return;
            }

            const piece = board[row][col];
            
            // If a piece is selected and the new click is a valid move target
            if (selectedPiece && canMove(selectedPiece.row, selectedPiece.col, row, col)) {
                await executeMove(selectedPiece.row, selectedPiece.col, row, col);
                selectedPiece = null;
                clearHighlights();
            } else if (piece && piece.color === playerColor) {
                // Select a new piece
                selectedPiece = { row, col, ...piece };
                clearHighlights();
                highlightValidMoves(row, col);
            }
        }
        
        async function executeMove(startRow, startCol, endRow, endCol) {
            if (!gameId) return; // Defensive check to prevent errors
            
            const piece = board[startRow][startCol];
            board[endRow][endCol] = piece;
            board[startRow][startCol] = null;
            
            // Check if it was a jump
            const isJump = Math.abs(endRow - startRow) === 2;
            if (isJump) {
                const jumpedRow = startRow + (endRow - startRow) / 2;
                const jumpedCol = startCol + (endCol - startCol) / 2;
                board[jumpedRow][jumpedCol] = null;
            }

            // Check for kinging
            if ((piece.color === 'red' && endRow === 7) || (piece.color === 'black' && endRow === 0)) {
                board[endRow][endCol].king = true;
            }
            
            // Update Firestore with the new board state
            const gameRef = doc(db, `artifacts/${appId}/public/data/games`, gameId);
            await updateDoc(gameRef, {
                board: JSON.stringify(board),
                turn: isJump && checkFurtherJumps(endRow, endCol) ? currentPlayer : (currentPlayer === 'black' ? 'red' : 'black'),
                winner: checkWinCondition() ? currentPlayer : null
            });
        }
        
        function canMove(startRow, startCol, endRow, endCol) {
            const piece = board[startRow][startCol];
            if (!piece || board[endRow][endCol] || piece.color !== playerColor) {
                return false;
            }
            
            const rowDiff = endRow - startRow;
            const colDiff = Math.abs(endCol - startCol);
            const directions = getMoveDirections(piece);
            const moveDirection = [Math.sign(rowDiff), Math.sign(endCol - startCol)];

            if (!directions.some(([dr, dc]) => dr === moveDirection[0] && dc === moveDirection[1])) {
                return false;
            }

            if (colDiff === 1 && Math.abs(rowDiff) === 1) {
                return !hasForcedJumps();
            }

            if (colDiff === 2 && Math.abs(rowDiff) === 2) {
                const jumpedRow = startRow + rowDiff / 2;
                const jumpedCol = startCol + (endCol - startCol) / 2;
                const jumpedPiece = board[jumpedRow][jumpedCol];
                return jumpedPiece && jumpedPiece.color !== playerColor;
            }
            
            return false;
        }

        function hasForcedJumps() {
            for (let r = 0; r < 8; r++) {
                for (let c = 0; c < 8; c++) {
                    const piece = board[r][c];
                    if (piece && piece.color === playerColor) {
                        if (getAllPossibleJumps(r, c).length > 0) {
                            return true;
                        }
                    }
                }
            }
            return false;
        }

        function checkFurtherJumps(row, col) {
            return getAllPossibleJumps(row, col).length > 0;
        }

        function getAllPossibleJumps(row, col) {
            const jumps = [];
            const piece = board[row][col];
            if (!piece) return jumps;
            const directions = getMoveDirections(piece);

            for (const [dr, dc] of directions) {
                const newRow = row + dr;
                const newCol = col + dc;
                const jumpRow = row + 2 * dr;
                const jumpCol = col + 2 * dc;

                if (isValidPosition(jumpRow, jumpCol) && !board[jumpRow][jumpCol] && board[newRow][newCol] && board[newRow][newCol].color !== piece.color) {
                    jumps.push({ startRow: row, startCol: col, endRow: jumpRow, endCol: jumpCol });
                }
            }
            return jumps;
        }
        
        function highlightValidMoves(row, col) {
            const pieceElement = document.querySelector(`[data-row="${row}"][data-col="${col}"] .piece`);
            if (pieceElement) {
                pieceElement.classList.add('selected');
            }
            
            const moves = getAllPossibleMoves(row, col);
            moves.forEach(move => {
                document.querySelector(`[data-row="${move.endRow}"][data-col="${move.endCol}"]`).classList.add('highlight');
            });
        }
        
        function getAllPossibleMoves(row, col) {
            const moves = [];
            const piece = board[row][col];
            if (!piece) return moves;

            const directions = getMoveDirections(piece);
            const forcedJumps = getAllPossibleJumps(row, col);

            if (forcedJumps.length > 0) {
                return forcedJumps;
            }

            for (const [dr, dc] of directions) {
                const newRow = row + dr;
                const newCol = col + dc;
                if (isValidPosition(newRow, newCol) && !board[newRow][newCol]) {
                    moves.push({ startRow: row, startCol: col, endRow: newRow, endCol: newCol });
                }
            }
            return moves;
        }

        // --- Bot Logic ---
        async function makeBotMove() {
            const botPieces = [];
            for (let r = 0; r < 8; r++) {
                for (let c = 0; c < 8; c++) {
                    if (board[r][c] && board[r][c].color === 'red') {
                        botPieces.push({ row: r, col: c });
                    }
                }
            }

            let availableMoves = [];
            let availableJumps = [];

            for (const piece of botPieces) {
                availableJumps.push(...getAllPossibleJumps(piece.row, piece.col).map(m => ({ ...m, piece: piece })));
                if (availableJumps.length === 0) {
                     availableMoves.push(...getAllPossibleMoves(piece.row, piece.col).map(m => ({ ...m, piece: piece })));
                }
            }
            
            const moves = availableJumps.length > 0 ? availableJumps : availableMoves;
            if (moves.length > 0) {
                const randomMove = moves[Math.floor(Math.random() * moves.length)];
                await executeMove(randomMove.startRow, randomMove.startCol, randomMove.endRow, randomMove.endCol);
                
                if (Math.abs(randomMove.endRow - randomMove.startRow) === 2 && checkFurtherJumps(randomMove.endRow, randomMove.endCol)) {
                    // Bot makes another jump
                    setTimeout(makeBotMove, 1000);
                }
            }
        }
        
        // --- Utility Functions ---

        function clearHighlights() {
            document.querySelectorAll('.square.highlight').forEach(square => square.classList.remove('highlight'));
            document.querySelectorAll('.piece.selected').forEach(piece => piece.classList.remove('selected'));
        }

        function isValidPosition(row, col) {
            return row >= 0 && row < 8 && col >= 0 && col < 8;
        }
        
        function getMoveDirections(piece) {
            if (piece.king) {
                return [[1, -1], [1, 1], [-1, -1], [-1, 1]];
            } else if (piece.color === 'red') {
                return [[1, -1], [1, 1]];
            } else { // black
                return [[-1, -1], [-1, 1]];
            }
        }
        
        function updateTurnDisplay(player1Name, player2Name) {
            if (isGameOver) return;
            const turnText = currentPlayer === playerColor ? 'Your Turn' : `${currentPlayer === 'black' ? player1Name : player2Name}'s Turn`;
            turnDisplay.textContent = `${turnText} (${currentPlayer})`;
        }
        
        function checkWinCondition() {
            let redPieces = 0;
            let blackPieces = 0;
            for (let i = 0; i < 8; i++) {
                for (let j = 0; j < 8; j++) {
                    const piece = board[i][j];
                    if (piece) {
                        if (piece.color === 'red') redPieces++;
                        if (piece.color === 'black') blackPieces++;
                    }
                }
            }
            return redPieces === 0 || blackPieces === 0;
        }
        
        function endGame(winner) {
            isGameOver = true;
            const winnerText = winner === 'red' ? 'Red' : 'Black';
            showMessage(`${winnerText} wins!`, 0);

            const restartBtn = document.createElement('button');
            restartBtn.textContent = 'Back to Menu';
            restartBtn.className = 'action-button';
            restartBtn.onclick = showMainMenu;
            messageBox.appendChild(restartBtn);
        }

        // Initial setup on page load
        window.onload = () => {
            initFirebase();
            showMainMenu();
        }
    </script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;700&display=swap');

        body {
            font-family: 'Inter', sans-serif;
            background: linear-gradient(135deg, #f5f7fa 0%, #c3cfe2 100%);
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            margin: 0;
            flex-direction: column;
            color: #333;
            text-align: center;
        }

        .container {
            background-color: #ffffff;
            padding: 30px;
            border-radius: 16px;
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.1);
            max-width: 95%;
            width: 500px;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 20px;
        }
        
        #game-container {
            display: none;
            flex-direction: column;
            align-items: center;
            width: 100%;
        }

        #main-menu {
            display: flex;
            flex-direction: column;
            align-items: center;
            width: 100%;
            gap: 20px;
        }

        #waiting-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.5);
            color: white;
            display: none;
            justify-content: center;
            align-items: center;
            flex-direction: column;
            font-size: 1.5rem;
            z-index: 999;
        }
        
        h1 {
            color: #2c3e50;
            margin: 0;
            font-size: 2.5rem;
            font-weight: 700;
        }

        #game-board {
            display: grid;
            grid-template-columns: repeat(8, 1fr);
            grid-template-rows: repeat(8, 1fr);
            width: 100%;
            max-width: 400px;
            margin: 20px auto;
            border: 5px solid #4a2c2a;
            border-radius: 8px;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.2);
            aspect-ratio: 1 / 1;
        }

        .square {
            width: 100%;
            aspect-ratio: 1 / 1;
            box-sizing: border-box;
            display: flex;
            justify-content: center;
            align-items: center;
            cursor: pointer;
            position: relative;
        }

        .square.dark {
            background: linear-gradient(to bottom right, #5d4037, #4a2c2a);
        }

        .square.light {
            background-color: #F8E8C0;
        }

        .piece {
            width: 80%;
            height: 80%;
            border-radius: 50%;
            box-shadow: inset 0 2px 5px rgba(0, 0, 0, 0.3), 0 5px 10px rgba(0, 0, 0, 0.2);
            display: flex;
            justify-content: center;
            align-items: center;
            font-weight: bold;
            color: #fff;
            transition: transform 0.3s ease-in-out;
            user-select: none;
            border: 2px solid rgba(255, 255, 255, 0.2);
            z-index: 10;
        }

        .piece.red {
            background: radial-gradient(circle at top left, #ef5350, #d32f2f);
        }

        .piece.black {
            background: radial-gradient(circle at top left, #5a5a5a, #333333);
        }

        .king::after {
            content: '★';
            font-size: 2.5em;
            color: gold;
            text-shadow: 0 0 10px rgba(255, 215, 0, 0.8);
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
        }

        .piece.selected {
            transform: scale(1.15) translateY(-5px);
            box-shadow: 0 0 15px #2196f3, 0 5px 20px rgba(0, 0, 0, 0.3);
            border: 3px solid #2196f3;
        }
        
        .square.highlight {
            background-color: #81c784 !important;
            box-shadow: inset 0 0 10px #4caf50;
            border-radius: 8px;
        }

        .message-box {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: rgba(33, 150, 243, 0.95);
            color: white;
            padding: 30px 50px;
            border-radius: 16px;
            box-shadow: 0 8px 16px rgba(0, 0, 0, 0.25);
            backdrop-filter: blur(5px);
            z-index: 1000;
            display: none;
            flex-direction: column;
            gap: 15px;
            align-items: center;
            font-size: 1.2rem;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.2);
        }

        .message-box.show {
            display: flex;
        }

        .info-display {
            display: flex;
            justify-content: space-between;
            align-items: center;
            width: 100%;
            padding: 10px;
            border-radius: 8px;
            background-color: #f7f9fc;
            box-shadow: inset 0 1px 3px rgba(0,0,0,0.1);
        }
        
        .player-turn, #turn-display {
            font-size: 1.2rem;
            font-weight: 700;
        }
        
        #user-id {
            font-size: 0.9rem;
            font-weight: 400;
            color: #777;
            text-align: right;
            align-self: flex-end;
            word-break: break-all;
        }
        
        .button-group, .game-buttons {
            display: flex;
            justify-content: center;
            gap: 15px;
            flex-wrap: wrap;
        }
        
        .menu-buttons {
            display: flex;
            flex-direction: column;
            gap: 15px;
            width: 100%;
        }

        .action-button {
            background: linear-gradient(45deg, #4CAF50, #8bc34a);
            color: white;
            border: none;
            padding: 12px 28px;
            font-size: 1.1rem;
            border-radius: 25px;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 4px 10px rgba(76, 175, 80, 0.3);
            text-transform: uppercase;
            font-weight: 700;
            letter-spacing: 1px;
            width: 100%;
        }

        .action-button:hover {
            background: linear-gradient(45deg, #388E3C, #689f38);
            box-shadow: 0 6px 15px rgba(56, 142, 60, 0.4);
            transform: translateY(-2px);
        }

        .action-button:active {
            transform: scale(0.98);
            box-shadow: 2px 2px 5px rgba(0, 0, 0, 0.2);
        }
        
        .input-group {
            display: flex;
            flex-direction: column;
            gap: 10px;
            width: 100%;
        }

        .input-group input {
            padding: 10px 15px;
            border-radius: 8px;
            border: 1px solid #ccc;
            font-size: 1rem;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Multiplayer Checkers</h1>
        
        <div id="user-id"></div>

        <!-- Main Menu -->
        <div id="main-menu">
            <p>Welcome! Please enter your username and choose an option.</p>
            <div class="input-group">
                <input type="text" id="username-input" placeholder="Enter your username">
            </div>
            <div class="menu-buttons">
                <button class="action-button" onclick="startNewGame()">Start a New Game (as Black)</button>
                <div class="input-group">
                    <input type="text" id="other-user-id-input" placeholder="Enter your friend's User ID">
                    <button class="action-button" onclick="joinGame()">Join Game (as Red)</button>
                </div>
                <button class="action-button" onclick="startBotGame()">Play against Bot</button>
            </div>
        </div>

        <!-- Game Interface -->
        <div id="game-container">
            <div id="game-board"></div>
            <div class="info-display">
                <span id="turn-display"></span>
            </div>
            <div class="button-group">
                <button class="action-button" onclick="undoMove()" id="undo-button">Undo Move</button>
                <button class="action-button" onclick="showMainMenu()">Back to Menu</button>
            </div>
        </div>
    </div>
