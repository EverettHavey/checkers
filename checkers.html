<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Checkers Game</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;700&display=swap');

        /* Base styling for the entire page */
        body {
            font-family: 'Inter', sans-serif;
            background: linear-gradient(135deg, #f5f7fa 0%, #c3cfe2 100%);
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            margin: 0;
            flex-direction: column;
            color: #333;
            text-align: center;
        }

        /* Main container for the game and menu */
        .container {
            background-color: #ffffff;
            padding: 30px;
            border-radius: 16px;
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.1);
            max-width: 95%;
            width: 500px;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 20px;
        }
        
        #game-container, #main-menu {
            display: none;
            width: 100%;
        }
        
        #main-menu.visible, #game-container.visible {
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        /* Title styling */
        h1 {
            color: #2c3e50;
            margin: 0;
            font-size: 2.5rem;
            font-weight: 700;
        }

        /* Game board and squares */
        #game-board {
            display: grid;
            grid-template-columns: repeat(8, 1fr);
            grid-template-rows: repeat(8, 1fr);
            width: 100%;
            max-width: 400px;
            margin: 20px auto;
            border: 5px solid #4a2c2a;
            border-radius: 8px;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.2);
            aspect-ratio: 1 / 1;
        }

        .square {
            width: 100%;
            aspect-ratio: 1 / 1;
            box-sizing: border-box;
            display: flex;
            justify-content: center;
            align-items: center;
            cursor: pointer;
            position: relative;
        }

        /* Dark squares with a wood texture gradient */
        .square.dark {
            background: linear-gradient(to bottom right, #5d4037, #4a2c2a);
        }

        /* Light squares with a clean cream color */
        .square.light {
            background-color: #F8E8C0;
        }

        /* Pieces with a 3D-like spherical look */
        .piece {
            width: 80%;
            height: 80%;
            border-radius: 50%;
            box-shadow: inset 0 2px 5px rgba(0, 0, 0, 0.3), 0 5px 10px rgba(0, 0, 0, 0.2);
            display: flex;
            justify-content: center;
            align-items: center;
            font-weight: bold;
            color: #fff;
            transition: transform 0.2s ease-in-out;
            user-select: none;
            border: 2px solid rgba(255, 255, 255, 0.2);
        }

        .piece.red {
            background: radial-gradient(circle at top left, #ef5350, #d32f2f);
        }

        .piece.black {
            background: radial-gradient(circle at top left, #5a5a5a, #333333);
        }

        /* King piece styling */
        .king::after {
            content: 'â˜…';
            font-size: 2.5em;
            color: gold;
            text-shadow: 0 0 10px rgba(255, 215, 0, 0.8);
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
        }

        /* Selected piece visual feedback */
        .piece.selected {
            transform: scale(1.15) translateY(-5px);
            box-shadow: 0 0 15px #2196f3, 0 5px 20px rgba(0, 0, 0, 0.3);
            border: 3px solid #2196f3;
        }

        /* Highlighted squares for valid moves */
        .square.highlight {
            background-color: #81c784 !important;
            box-shadow: inset 0 0 10px #4caf50;
            border-radius: 8px;
        }

        /* Message box pop-up */
        .message-box {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: rgba(33, 150, 243, 0.95);
            color: white;
            padding: 30px 50px;
            border-radius: 16px;
            box-shadow: 0 8px 16px rgba(0, 0, 0, 0.25);
            backdrop-filter: blur(5px);
            z-index: 1000;
            display: none;
            flex-direction: column;
            gap: 15px;
            align-items: center;
            font-size: 1.2rem;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.2);
        }

        .message-box.show {
            display: flex;
        }

        /* Player turn and info display */
        .info-display {
            display: flex;
            justify-content: space-between;
            align-items: center;
            width: 100%;
            padding: 10px;
            border-radius: 8px;
            background-color: #f7f9fc;
            box-shadow: inset 0 1px 3px rgba(0,0,0,0.1);
        }
        
        .player-turn, #turn-display, #timer-display {
            font-size: 1.2rem;
            font-weight: 700;
        }

        .timer-display {
            color: #d32f2f;
        }
        
        /* User ID text */
        .user-id-display {
            font-size: 0.8rem;
            color: #666;
            margin-top: 10px;
            word-break: break-all;
        }

        /* Button styling */
        .button-group, .game-buttons {
            display: flex;
            justify-content: center;
            gap: 15px;
            flex-wrap: wrap;
        }

        .action-button {
            background-color: #4CAF50;
            background: linear-gradient(45deg, #4CAF50, #8bc34a);
            color: white;
            border: none;
            padding: 12px 28px;
            font-size: 1.1rem;
            border-radius: 25px;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 4px 10px rgba(76, 175, 80, 0.3);
            text-transform: uppercase;
            font-weight: 700;
            letter-spacing: 1px;
        }

        .action-button:hover {
            background: linear-gradient(45deg, #388E3C, #689f38);
            box-shadow: 0 6px 15px rgba(56, 142, 60, 0.4);
            transform: translateY(-2px);
        }

        .action-button:active {
            transform: scale(0.98);
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
        }
        
        .game-buttons button {
            width: 100%;
            max-width: 250px;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Checkers</h1>
        <div id="main-menu" class="visible">
            <p>Choose your game mode:</p>
            <div class="game-buttons">
                <button class="action-button" id="single-player-btn">Single Player</button>
                <button class="action-button" id="multi-player-btn">Multi Player</button>
            </div>
        </div>
        <div id="game-container">
            <div id="game-board"></div>
            <div class="info-display">
                <span id="turn-display"></span>
                <span id="timer-display" class="timer-display"></span>
            </div>
            <div class="button-group">
                <button class="action-button" onclick="backToMenu()">Back to Menu</button>
            </div>
            <div class="user-id-display" id="user-id-display"></div>
        </div>
    </div>
    
    <div class="message-box" id="message-box"></div>

    <script type="module">
        // Import Firebase modules. These are globally available in the canvas environment.
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, signInWithCustomToken, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, doc, getDoc, setDoc, onSnapshot, collection, query, where, getDocs, addDoc, updateDoc } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

        // Global variables provided by the canvas environment for Firebase setup.
        const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';
        const firebaseConfig = typeof __firebase_config !== 'undefined' ? JSON.parse(__firebase_config) : {};
        const initialAuthToken = typeof __initial_auth_token !== 'undefined' ? __initial_auth_token : null;

        // Game state variables
        let board = [];
        let currentPlayer = 'black'; // 'black' or 'red'
        let selectedPiece = null;
        let isGameOver = false;
        let gameMode = null; // 'single' or 'multi'
        let timerInterval;
        let timeLeft = 60; // 60 seconds per turn
        let userId = null;
        let gameId = null;
        let playerColor = null; // 'black' or 'red' for the current user
        let opponentUserId = null;
        let canEndTurn = true;

        // Firebase instances
        let app, db, auth;

        // Game UI elements
        const mainMenu = document.getElementById('main-menu');
        const gameContainer = document.getElementById('game-container');
        const boardElement = document.getElementById('game-board');
        const userIdDisplay = document.getElementById('user-id-display');
        const messageBox = document.getElementById('message-box');
        
        // --- Firebase Initialization and Authentication ---
        async function initializeFirebase() {
            try {
                if (Object.keys(firebaseConfig).length > 0) {
                    app = initializeApp(firebaseConfig);
                    db = getFirestore(app);
                    auth = getAuth(app);

                    onAuthStateChanged(auth, async (user) => {
                        if (user) {
                            userId = user.uid;
                            console.log("Authenticated with user ID:", userId);
                            userIdDisplay.textContent = `Your ID: ${userId}`;
                        } else {
                            // If not authenticated, sign in with the provided custom token or anonymously.
                            if (initialAuthToken) {
                                await signInWithCustomToken(auth, initialAuthToken);
                            } else {
                                await signInAnonymously(auth);
                            }
                        }
                    });
                } else {
                    console.error("Firebase config is not available. Please check the environment setup.");
                }
            } catch (error) {
                console.error("Error initializing Firebase:", error);
            }
        }

        // --- Game Setup and Logic ---

        // Display a message in a custom message box
        function showMessage(text, duration = 3000) {
            messageBox.textContent = text;
            messageBox.classList.add('show');
            setTimeout(() => {
                messageBox.classList.remove('show');
            }, duration);
        }

        // Reset the game board to its initial state
        function createBoard() {
            board = [];
            for (let i = 0; i < 8; i++) {
                board.push([]);
                for (let j = 0; j < 8; j++) {
                    let piece = null;
                    if (i < 3 && (i + j) % 2 !== 0) {
                        piece = { color: 'red', king: false };
                    } else if (i > 4 && (i + j) % 2 !== 0) {
                        piece = { color: 'black', king: false };
                    }
                    board[i].push(piece);
                }
            }
        }

        // Render the board to the DOM
        function renderBoard() {
            boardElement.innerHTML = '';
            for (let i = 0; i < 8; i++) {
                for (let j = 0; j < 8; j++) {
                    const square = document.createElement('div');
                    square.className = `square ${(i + j) % 2 === 0 ? 'light' : 'dark'}`;
                    square.dataset.row = i;
                    square.dataset.col = j;
                    square.addEventListener('click', () => handleSquareClick(i, j));

                    const piece = board[i][j];
                    if (piece) {
                        const pieceElement = document.createElement('div');
                        pieceElement.className = `piece ${piece.color} ${piece.king ? 'king' : ''}`;
                        square.appendChild(pieceElement);
                    }
                    boardElement.appendChild(square);
                }
            }
        }

        // Start the game
        async function startGame(mode) {
            mainMenu.classList.remove('visible');
            gameContainer.classList.add('visible');
            isGameOver = false;
            canEndTurn = true;
            gameMode = mode;
            createBoard();
            renderBoard();

            if (mode === 'single') {
                playerColor = 'black';
                currentPlayer = 'black';
                document.getElementById('turn-display').textContent = 'Your Turn';
                startTimer();
            } else if (mode === 'multi') {
                if (!userId) {
                    showMessage("Authenticating...");
                    return;
                }
                showMessage("Looking for an opponent...");
                await joinOrCreateGame();
                console.log(`Multiplayer game started. Game ID: ${gameId}, Player Color: ${playerColor}`);
            }
        }
        
        async function joinOrCreateGame() {
            const gamesRef = collection(db, `artifacts/${appId}/public/data/checkers_games`);
            const q = query(gamesRef, where("status", "==", "waiting"));
            const querySnapshot = await getDocs(q);
            
            let foundGame = false;
            if (!querySnapshot.empty) {
                // Join an existing waiting game
                querySnapshot.forEach(async (doc) => {
                    const gameData = doc.data();
                    if (gameData.player1 !== userId) {
                        gameId = doc.id;
                        playerColor = 'red'; // Second player is always red
                        opponentUserId = gameData.player1;
                        await setDoc(doc.ref, { player2: userId, status: "playing" }, { merge: true });
                        setupRealtimeListener();
                        showMessage("Game started! You are Red.");
                        userIdDisplay.style.display = 'block';
                        userIdDisplay.textContent = `Your ID: ${userId}. Opponent's ID: ${opponentUserId}`;
                        foundGame = true;
                    }
                });
            }
            
            if (!foundGame) {
                // Create a new game
                playerColor = 'black'; // First player is always black
                const newGameRef = await addDoc(gamesRef, {
                    player1: userId,
                    player2: null,
                    status: "waiting",
                    board: JSON.stringify(board),
                    currentPlayer: 'black'
                });
                gameId = newGameRef.id;
                showMessage("Waiting for an opponent. Share your ID.");
                userIdDisplay.style.display = 'block';
                userIdDisplay.textContent = `Your ID: ${userId}. Waiting for opponent...`;
                setupRealtimeListener();
            }
        }
        
        function setupRealtimeListener() {
            const gameRef = doc(db, `artifacts/${appId}/public/data/checkers_games`, gameId);
            onSnapshot(gameRef, (doc) => {
                const gameData = doc.data();
                if (gameData) {
                    if (gameData.player2 && !opponentUserId) {
                        opponentUserId = gameData.player2;
                        userIdDisplay.textContent = `Your ID: ${userId}. Opponent's ID: ${opponentUserId}`;
                        showMessage("Opponent joined! Game is starting.");
                    }
                    if (gameData.status === "playing") {
                        board = JSON.parse(gameData.board);
                        currentPlayer = gameData.currentPlayer;
                        renderBoard();
                        updateTurnDisplay();
                        // Reset timer on turn change
                        startTimer();
                        if (isGameOver) {
                            return;
                        }
                        
                        // Check for winner after a move
                        if(checkWinCondition()) {
                            endGame();
                        }
                    }
                }
            });
        }
        
        // Update the Firebase document with the current game state
        async function updateGameInFirestore() {
            if (gameId) {
                const gameRef = doc(db, `artifacts/${appId}/public/data/checkers_games`, gameId);
                await updateDoc(gameRef, {
                    board: JSON.stringify(board),
                    currentPlayer: currentPlayer
                });
            }
        }
        
        // Logic for handling a square click
        async function handleSquareClick(row, col) {
            if (isGameOver || (gameMode === 'multi' && currentPlayer !== playerColor) || !canEndTurn) {
                return;
            }

            const piece = board[row][col];
            
            // If a piece is selected and the new click is a valid move
            if (selectedPiece && canMove(selectedPiece.row, selectedPiece.col, row, col)) {
                const isJump = movePiece(selectedPiece.row, selectedPiece.col, row, col);
                
                // If a jump was made, check for further jumps from the new position
                if (isJump) {
                    selectedPiece = { row, col, ...board[row][col] };
                    const nextJumps = getAllPossibleJumps(row, col);
                    if (nextJumps.length > 0) {
                        // Keep the turn active and highlight next jumps
                        canEndTurn = false;
                        clearHighlights();
                        highlightMoves(nextJumps);
                        return; // Exit without switching turn
                    }
                }

                // If no jump was made or no more jumps are available, end the turn
                selectedPiece = null;
                clearHighlights();
                canEndTurn = true;
                
                // End the game if a player wins
                if(checkWinCondition()){
                    endGame();
                } else {
                    switchTurn();
                }
                
            } else if (piece && piece.color === currentPlayer) {
                // Select a new piece if it's the current player's turn
                selectedPiece = { row, col, ...piece };
                clearHighlights();
                highlightValidMoves(row, col);
            }
        }

        // Clear all highlighted squares
        function clearHighlights() {
            document.querySelectorAll('.square.highlight').forEach(square => {
                square.classList.remove('highlight');
            });
            document.querySelectorAll('.piece.selected').forEach(piece => {
                piece.classList.remove('selected');
            });
        }
        
        // Get all possible moves for a piece (single moves and jumps)
        function getAllPossibleMoves(row, col) {
            const moves = [];
            const piece = board[row][col];
            if (!piece) return moves;

            const directions = getMoveDirections(piece);

            for (const [dr, dc] of directions) {
                // Check for single moves
                const newRow = row + dr;
                const newCol = col + dc;
                if (isValidPosition(newRow, newCol) && !board[newRow][newCol]) {
                    moves.push({ startRow: row, startCol: col, endRow: newRow, endCol: newCol });
                }
                
                // Check for jump moves
                const jumpRow = row + 2 * dr;
                const jumpCol = col + 2 * dc;
                if (isValidPosition(jumpRow, jumpCol) && !board[jumpRow][jumpCol] && board[newRow][newCol] && board[newRow][newCol].color !== piece.color) {
                    moves.push({ startRow: row, startCol: col, endRow: jumpRow, endCol: jumpCol });
                }
            }
            return moves;
        }

        // Get all possible jump moves for a piece
        function getAllPossibleJumps(row, col) {
            const jumps = [];
            const piece = board[row][col];
            if (!piece) return jumps;

            const directions = getMoveDirections(piece);

            for (const [dr, dc] of directions) {
                const newRow = row + dr;
                const newCol = col + dc;
                const jumpRow = row + 2 * dr;
                const jumpCol = col + 2 * dc;

                if (isValidPosition(jumpRow, jumpCol) && !board[jumpRow][jumpCol] && board[newRow][newCol] && board[newRow][newCol].color !== piece.color) {
                    jumps.push({ startRow: row, startCol: col, endRow: jumpRow, endCol: jumpCol });
                }
            }
            return jumps;
        }

        // Highlight a list of moves on the board
        function highlightMoves(moves) {
            moves.forEach(move => {
                document.querySelector(`[data-row="${move.endRow}"][data-col="${move.endCol}"]`).classList.add('highlight');
            });
        }

        // Highlight valid moves for a selected piece
        function highlightValidMoves(row, col) {
            const piece = board[row][col];
            const pieceElement = document.querySelector(`[data-row="${row}"][data-col="${col}"] .piece`);
            if (pieceElement) {
                pieceElement.classList.add('selected');
            }

            const moves = getAllPossibleMoves(row, col);
            highlightMoves(moves);
        }
        
        // Get valid move directions for a piece
        function getMoveDirections(piece) {
            if (piece.king) {
                return [[1, -1], [1, 1], [-1, -1], [-1, 1]];
            } else if (piece.color === 'red') {
                return [[1, -1], [1, 1]];
            } else { // black
                return [[-1, -1], [-1, 1]];
            }
        }

        // Check if a move is valid
        function canMove(startRow, startCol, endRow, endCol) {
            const piece = board[startRow][startCol];
            if (!piece || board[endRow][endCol]) {
                return false;
            }

            const rowDiff = endRow - startRow;
            const colDiff = Math.abs(endCol - startCol);
            
            const directions = getMoveDirections(piece);
            const moveDirection = [Math.sign(rowDiff), Math.sign(endCol - startCol)];

            // Check if the move direction is allowed
            if (!directions.some(([dr, dc]) => dr === moveDirection[0] && dc === moveDirection[1])) {
                return false;
            }

            // Simple move
            if (colDiff === 1 && Math.abs(rowDiff) === 1) {
                return true;
            }

            // Jump move
            if (colDiff === 2 && Math.abs(rowDiff) === 2) {
                const jumpedRow = startRow + rowDiff / 2;
                const jumpedCol = startCol + (endCol - startCol) / 2;
                const jumpedPiece = board[jumpedRow][jumpedCol];
                return jumpedPiece && jumpedPiece.color !== currentPlayer;
            }
            
            return false;
        }

        // Execute a move on the board and return true if it was a jump
        function movePiece(startRow, startCol, endRow, endCol) {
            const piece = board[startRow][startCol];
            board[endRow][endCol] = piece;
            board[startRow][startCol] = null;
            
            let isJump = false;
            // Check for jump and remove jumped piece
            const rowDiff = endRow - startRow;
            const colDiff = Math.abs(endCol - startCol);
            if (colDiff === 2) {
                const jumpedRow = startRow + rowDiff / 2;
                const jumpedCol = startCol + (endCol - startCol) / 2;
                board[jumpedRow][jumpedCol] = null;
                isJump = true;
            }

            // Check for kinging
            if ((piece.color === 'red' && endRow === 7) || (piece.color === 'black' && endRow === 0)) {
                board[endRow][endCol].king = true;
            }
            
            renderBoard();
            return isJump;
        }

        // Switch the turn to the other player
        function switchTurn() {
            currentPlayer = currentPlayer === 'black' ? 'red' : 'black';
            updateTurnDisplay();
            startTimer();
            if (gameMode === 'multi') {
                updateGameInFirestore();
            } else if (gameMode === 'single' && currentPlayer === 'red') {
                setTimeout(botMove, 1000);
            }
        }
        
        function updateTurnDisplay() {
            const turnText = gameMode === 'multi'
                ? (currentPlayer === playerColor ? 'Your Turn' : `Opponent's Turn`)
                : (currentPlayer === 'black' ? 'Your Turn' : 'Bot\'s Turn');
            document.getElementById('turn-display').textContent = turnText;
        }

        // Check if the game is over
        function checkWinCondition() {
            let redPieces = 0;
            let blackPieces = 0;
            for (let i = 0; i < 8; i++) {
                for (let j = 0; j < 8; j++) {
                    const piece = board[i][j];
                    if (piece) {
                        if (piece.color === 'red') redPieces++;
                        if (piece.color === 'black') blackPieces++;
                    }
                }
            }
            return redPieces === 0 || blackPieces === 0;
        }

        // End the game and display the winner
        function endGame(timeout = false) {
            isGameOver = true;
            clearInterval(timerInterval);
            let winner = '';
            if (timeout) {
                winner = currentPlayer === 'black' ? 'Red' : 'Black';
                showMessage(`Time's up! ${winner} wins!`, 5000);
            } else {
                winner = currentPlayer === 'black' ? 'Black' : 'Red';
                showMessage(`${winner} wins!`, 5000);
            }

            // Display a restart button
            const restartBtn = document.createElement('button');
            restartBtn.textContent = 'Play Again';
            restartBtn.className = 'action-button';
            restartBtn.onclick = () => {
                backToMenu();
            };
            messageBox.appendChild(restartBtn);
            messageBox.classList.add('show');
        }

        // --- Bot Logic (Simple AI) ---
        function botMove() {
            console.log("Bot's turn. Looking for moves...");
            let allMoves = [];
            let jumpMoves = [];
            for (let i = 0; i < 8; i++) {
                for (let j = 0; j < 8; j++) {
                    const piece = board[i][j];
                    if (piece && piece.color === 'red') {
                        allMoves = allMoves.concat(getAllPossibleMoves(i, j));
                        jumpMoves = jumpMoves.concat(getAllPossibleJumps(i,j));
                    }
                }
            }
            
            let move;
            if (jumpMoves.length > 0) {
                // If jumps are available, the bot prioritizes them
                move = jumpMoves[Math.floor(Math.random() * jumpMoves.length)];
                const jumped = movePiece(move.startRow, move.startCol, move.endRow, move.endCol);

                // Check for subsequent jumps
                if (jumped) {
                    let currentPosition = { row: move.endRow, col: move.endCol };
                    let nextJumps = getAllPossibleJumps(currentPosition.row, currentPosition.col);
                    while (nextJumps.length > 0) {
                        const nextMove = nextJumps[Math.floor(Math.random() * nextJumps.length)];
                        movePiece(currentPosition.row, currentPosition.col, nextMove.endRow, nextMove.endCol);
                        currentPosition = { row: nextMove.endRow, col: nextMove.endCol };
                        nextJumps = getAllPossibleJumps(currentPosition.row, currentPosition.col);
                    }
                }
            } else if (allMoves.length > 0) {
                // Otherwise, make a random normal move
                move = allMoves[Math.floor(Math.random() * allMoves.length)];
                movePiece(move.startRow, move.startCol, move.endRow, move.endCol);
            } else {
                console.log("Bot has no moves. Ending game.");
                endGame();
                return;
            }

            if (checkWinCondition()) {
                endGame();
            } else {
                switchTurn();
            }
        }


        // --- Helper Functions ---
        function isValidPosition(row, col) {
            return row >= 0 && row < 8 && col >= 0 && col < 8;
        }

        // --- Timer Functions ---
        function startTimer() {
            clearInterval(timerInterval);
            timeLeft = 60;
            document.getElementById('timer-display').textContent = `Time Left: ${timeLeft}`;
            timerInterval = setInterval(() => {
                timeLeft--;
                document.getElementById('timer-display').textContent = `Time Left: ${timeLeft}`;
                if (timeLeft <= 0) {
                    endGame(true);
                }
            }, 1000);
        }

        // Back to Menu function
        function backToMenu() {
            localStorage.removeItem('gameMode');
            window.location.reload();
        }

        // --- Event Listeners for menu buttons ---
        document.getElementById('single-player-btn').addEventListener('click', () => {
            localStorage.setItem('gameMode', 'single');
            startGame('single');
        });

        document.getElementById('multi-player-btn').addEventListener('click', () => {
            localStorage.setItem('gameMode', 'multi');
            startGame('multi');
        });

        // Initial setup
        window.onload = async () => {
            await initializeFirebase();
            const savedGameMode = localStorage.getItem('gameMode');
            if (savedGameMode) {
                startGame(savedGameMode);
            } else {
                mainMenu.classList.add('visible');
            }
        };

    </script>
</body>
</html>
